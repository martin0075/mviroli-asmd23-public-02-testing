## **Task 1 : Reorganise**

This task involves using the Mockito feature to implement unit tests based on the TDD approach. 

Specifically, the goal is to reorganize the provided tests and possibly create new ones, making appropriate use of all types of test doubles: Mock, Spy, Fakes, Dummy, and Stub. 

The file containing the implemented tests is located within the Reorganize package.

## **Task 2: ATDD-LLM**
LLMs/ChatGPT can arguably help in write/improve/complete/implement/reverse-engineer a JUnit test, either unit or integration test.
Experiment with this, based on the above tasks or in other cases. Is ChatGPT useful for all that?

In this task, I provided ChatGPT with the code for StandardDevice and asked it to generate a suite of JUnit tests using a TDD approach, leveraging Mockito and all its features appropriately: Dummy, Stub, Mock, Fakes and Spy. Here is the generated code:
```
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class StandardDeviceTest {
    private StandardDevice standardDevice;
    private FailingPolicy failingPolicy;

    @BeforeEach
    void setUp() {
        failingPolicy = Mockito.mock(FailingPolicy.class);
        standardDevice = new StandardDevice(failingPolicy);
    }

    @Test
    void testTurnOnDevice_Success() {
        when(failingPolicy.attemptOn()).thenReturn(true);
        assertFalse(standardDevice.isOn());
        assertDoesNotThrow(() -> standardDevice.on());
        assertTrue(standardDevice.isOn());
    }

    @Test
    void testTurnOnDevice_Failure() {
        when(failingPolicy.attemptOn()).thenReturn(false);
        assertFalse(standardDevice.isOn());
        assertThrows(IllegalStateException.class, () -> standardDevice.on());
        assertFalse(standardDevice.isOn());
    }

    @Test
    void testTurnOffDevice() {
        standardDevice.on();
        assertTrue(standardDevice.isOn());
        standardDevice.off();
        assertFalse(standardDevice.isOn());
    }

    @Test
    void testResetDevice() {
        standardDevice.on();
        assertTrue(standardDevice.isOn());
        standardDevice.reset();
        assertFalse(standardDevice.isOn());
        verify(failingPolicy, times(1)).reset();
    }

    @Test
    void testToString() {
        when(failingPolicy.policyName()).thenReturn("MockPolicy");
        String expectedString = "StandardDevice{policy=MockPolicy, on=false}";
        assertEquals(expectedString, standardDevice.toString());
    }
}
```

Comparing the provided code with the one generated by me in Task 1, we can notice that ChatGPT did not properly apply TDD, 
as it created JUnit tests that do not fully cover all functionalities. Specifically, there are missing tests for the initial object creation, the initial check if the device is turned off, and the simultaneous verification of device powering on and off.

Additionally, ChatGPT initially created a **mock** to simulate the behavior of FailingPolicy during tests, avoiding dependency on its real implementation. 
Subsequently, in the tests, it predominantly used **stubs** specifying what the attemptOn() method should return in certain scenarios. 
In one instance, a **spy** was used to verify if the reset method was called correctly.

In conclusion, in my opinion, and based also on the code produced in Task 1, ChatGPT made limited use of all Mockito 
features to test the various functionalities of the system, primarily focusing on **stubs**.